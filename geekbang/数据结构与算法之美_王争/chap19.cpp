#include <iostream>
#include <vector>

using namespace std;

// 常用的解决散列冲突的方法是开放寻址和链表法
// 开放寻址的优点是简单、易序列化、能更好的利用缓存
// 链表法的优点是对装载因子的容忍度高
//
// 链表法可以稍加改造，变得更高效
// 如将链表更换为跳表、红黑树等高效的动态数据结构
// 避免极端情况下数据聚集到某个链表中导致的极度低效
// 改造后，即使极端情况下，也只是退化到O(logn)而已
//
//
// 根据装载因子动态扩容
// 大了扩，小了缩
// 扩容搬动数据的复杂度是O(n)，
// 摊还分析法，均摊情况下，时间复杂度还是O(1)
//
// 在扩容的时候，可以将数据搬动的过程均摊到每次有新数据插入到新散列表中之后
// 这样避免老散列表过大而需要扩容时，数据搬动造成的耗时过多问题
//
//
// 工业级散列表分析，以Java的HashMap为例
// 初始大小：默认的初始大小为16
// 装载因子：默认的装载因子为0.75，超过阈值则扩容为原来的两倍
// 散列冲突：链表法
//           自JDK1.8开始引入红黑树，当链表过程（默认为超过8），则链表转为红黑树
//           当红黑树结点数少于8，则红黑树转为链表
// 散列函数：根据Java对象的HashCode()计算 
//           hashcode是JAVA规范要求的每个对象必须保证唯一的32位整型值，因而重写equals的时候必须重写hashcode

int main()
{
    return 0;
}

